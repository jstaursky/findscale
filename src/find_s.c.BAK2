#include <gtk/gtk.h>
#include <cairo.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <glib.h>
#include <glib/gprintf.h>

#include <string.h>
#include <ctype.h>
#include "LinkedList.h"

// gcc -o find_s find_s.c `pkg-config --cflags --libs gtk+-3.0`

static gboolean drawArea_draw (GtkWidget *widget, cairo_t *cr,
                                gpointer *usr_arg)
{
    GdkPixbuf *pix_scaled, *pixbuf = *usr_arg;
    GdkWindow *window;
    gint width, height;

    window = gtk_widget_get_window (widget);
    height = gdk_window_get_height (window);
    // Calculate width such that aspect ratio is retained during rescale.
    width = (gdk_pixbuf_get_width (pixbuf) * height) /
            gdk_pixbuf_get_height (pixbuf);

    pix_scaled =
        gdk_pixbuf_scale_simple (pixbuf, width, height, GDK_INTERP_BILINEAR);

    gdk_cairo_set_source_pixbuf (cr, pix_scaled, 0, 0);
    cairo_paint (cr);

    g_object_unref (pix_scaled);

    return FALSE;
}

gchar *getResourceFileName(gchar *keysig, gchar *interval)
{
    if (keysig == NULL || interval == NULL)
        return NULL;
    gchar *fname;


    //   g_snprinf (fname, 80, "%s")

    return g_strdup(fname);
}

void
configurePixbufRender(GdkPixbuf** pixbuf, gchar *keysig, gchar *interval)
{
    GdkPixbuf* pianoPixbuf;
    cairo_surface_t* paint_dest;
    cairo_t* cr;
    cairo_surface_t* paint_src;

    pianoPixbuf = gdk_pixbuf_new_from_file("imgs/piano.png", NULL);

    paint_dest = cairo_image_surface_create(
        CAIRO_FORMAT_ARGB32, gdk_pixbuf_get_width(pianoPixbuf), gdk_pixbuf_get_height(pianoPixbuf));
    cr = cairo_create(paint_dest);
    cairo_surface_destroy(paint_dest);

    gdk_cairo_set_source_pixbuf(cr, pianoPixbuf, 0, 0);
    cairo_paint(cr);

    // will need to loop this
    gchar *fname = getResourceFileName(keysig, interval);

    paint_src = cairo_image_surface_create_from_png(fname); // e.g. "piano-A-notes.png"
    if (cairo_surface_status (paint_src) == CAIRO_STATUS_SUCCESS) {
        cairo_set_source_surface(cr, paint_src, 0, 0);
        cairo_paint(cr); // write to paint_dest.
    } else {
        puts ("paint_src error");
    }

    *pixbuf =
        gdk_pixbuf_get_from_surface(paint_dest, 0, 0,
                                    cairo_image_surface_get_width(paint_dest),
                                    cairo_image_surface_get_height(paint_dest));
    // Clean up.
    cairo_surface_destroy(paint_src);

    cairo_destroy(cr);
}

char *fgetline(FILE *stream);

int main(int argc, char **argv) {
  GtkWidget *window, *container, *draw_area;
  GdkPixbuf *pixbuf;

  gtk_init(&argc, &argv);

  window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
  container = gtk_layout_new(NULL, NULL);
  draw_area = gtk_drawing_area_new();

  configurePixbufRender(&pixbuf, NULL, NULL);

  gtk_window_set_default_size(GTK_WINDOW(window), 975, 260);

  // Signals
  g_signal_connect(G_OBJECT(draw_area), "draw", G_CALLBACK(drawArea_draw),
                   (gpointer)&pixbuf);

  g_signal_connect(G_OBJECT(window), "destroy", G_CALLBACK(gtk_main_quit),
                   NULL);

  GtkWidget *box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 10);
  gtk_box_pack_start(GTK_BOX(box), draw_area, TRUE, TRUE, 0);

  // new ////////////////////////////////////////////////////////////////////
  GtkWidget *listBoxScaleNames = gtk_combo_box_text_new();
  gtk_box_pack_start(GTK_BOX(box), listBoxScaleNames, FALSE, TRUE, 0);

  struct List *list = createList();

  FILE *configfp = fopen("conf/scale.list", "r");

  for (char *line; (line = fgetline(configfp)); ) {
      char *name, *intervals;
      char *rest = line;
      name = strtok_r (line, ",", &rest);
      while (isspace(*rest))
          ++rest;
      intervals = rest;
      addToList(&list, name, intervals);
  }
  struct ScaleInfo *scaleDb = getInfo (&list);

  for (int i = 0; i < list->len; ++i) {
      gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(listBoxScaleNames), scaleDb[i].name);
  }
  // start new widget addition
  GtkWidget *listBoxScaleIntervals = gtk_combo_box_text_new();
  gtk_box_pack_start(GTK_BOX(box), listBoxScaleIntervals, FALSE, TRUE, 0);

  for (int i = 0; i < list->len; ++i) {
    gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(listBoxScaleIntervals),
                                   scaleDb[i].intervals); ///!!!
  }
  // end new widget additions





  // end new //////////////////////////////////////////////////////////////

  gtk_container_add(GTK_CONTAINER(window), box);

  gtk_widget_show_all(window);
  gtk_main();

  return 0;
}

char *fgetline(FILE *stream) {
  const size_t chunk = 128;
  size_t max = chunk;

  /* Preliminary check */
  if (!stream || feof(stream))
    return NULL;

  char *buffer = (char *)malloc(chunk * sizeof(char));
  if (!buffer) {
    perror("Unable to allocate space");
    return NULL;
  }
  char *ptr = buffer;
  int c; /* fgetc returns int. Comparing EOF w/ char may
          * cause issues. */
  while ((c = fgetc(stream)) != EOF && (*ptr = c) != '\n') {
    ++ptr;
    size_t offset = ptr - buffer;
    if (offset >= max) {

      max += chunk;

      char *tmp = realloc(buffer, max);
      if (!tmp) {
        free(buffer);
        return NULL;
      }
      buffer = tmp;
      ptr = tmp + offset;
    }
  }
  *ptr = '\0';
  return buffer;
}
